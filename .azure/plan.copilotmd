# Azure Deployment Plan for PhotoAlbum-Java Project

## **Goal**
Deploy the PhotoAlbum-Java application to Azure using Azure Developer CLI (AZD), migrating from local Docker Compose setup to Azure Container Apps with managed PostgreSQL database.

## **Project Information**

**PhotoAlbum-Java**
- **Stack**: Spring Boot 2.7.18 (Java 8)
- **Type**: Photo gallery web application with upload, browse, and management features
- **Current Setup**: Docker Compose with Oracle Database
- **Containerization**: Dockerfile present (multi-stage build with Maven)
- **Dependencies**: 
  - Database: Oracle (to be migrated to PostgreSQL)
  - Storage: Database BLOBs (to be migrated to Azure Blob Storage)
  - Container Registry: Required for Azure deployment
- **Hosting**: Azure Container Apps (recommended for auto-scaling and cost efficiency)

## **Azure Resources Architecture**

> **Install the mermaid extension in IDE to view the architecture.**

```mermaid
graph TD
%% Services
svcazurecontainerapps_photoalbumjavaapp["`Name: photoalbum-java-app
Path: /home/runner/work/PhotoAlbum-Java/PhotoAlbum-Java
Language: java`"]
subgraph "Compute Resources"
%% Resources
subgraph containerappenv["Azure Container Apps (ACA) Environment"]
azurecontainerapps_photoalbumjavaapp("`photoalbum-java-app (Azure Container App)`")
end
containerappenv:::cluster
end
subgraph "Dependency Resources"
%% Dependency Resources
azure_azuredatabaseforpostgresql["`Azure Database for PostgreSQL`"]
azure_azurestorageaccount["`Azure Storage Account`"]
azure_azurecontainerregistry["`Azure Container Registry`"]
azure_keyvault["`Azure Key Vault`"]
azure_appinsights["`Application Insights`"]
azure_loganalytics["`Log Analytics Workspace`"]
end
%% Relationships
svcazurecontainerapps_photoalbumjavaapp --> |"hosted on"| azurecontainerapps_photoalbumjavaapp
azurecontainerapps_photoalbumjavaapp -.-> |"depends on"| azure_azuredatabaseforpostgresql
azurecontainerapps_photoalbumjavaapp -.-> |"depends on"| azure_azurestorageaccount
azurecontainerapps_photoalbumjavaapp -.-> |"depends on"| azure_azurecontainerregistry
azurecontainerapps_photoalbumjavaapp -.-> |"depends on"| azure_keyvault
azurecontainerapps_photoalbumjavaapp -.-> |"depends on"| azure_appinsights
azure_appinsights -.-> |"logs to"| azure_loganalytics
```

**Architecture Overview:**
- The container app is built from the Dockerfile and pushed to Azure Container Registry
- The container app retrieves its image from the Azure Container Registry using managed identity
- The application connects to Azure Database for PostgreSQL for data persistence
- Photos are stored in Azure Blob Storage for scalability and performance
- Connection strings and secrets are stored in Azure Key Vault
- Application Insights monitors the app and logs to Log Analytics Workspace
- Managed Identity handles all authentication between Azure services

## **Recommended Azure Resources**

### Application: PhotoAlbum-Java

**Hosting Service Type:** Azure Container Apps

**SKU:** 
- Consumption plan (0.5 vCPU, 1.0 GiB memory per instance)
- Auto-scaling: 0-10 replicas based on HTTP traffic
- Performance: Suitable for small to medium workloads with burst capability

**Configuration:**
- **Language:** Java 8
- **Environment Variables:**
  - `SPRING_DATASOURCE_URL`: Connection string to PostgreSQL (from Key Vault)
  - `SPRING_DATASOURCE_USERNAME`: Database username (from Key Vault)
  - `SPRING_DATASOURCE_PASSWORD`: Database password (from Key Vault)
  - `AZURE_STORAGE_ACCOUNT_NAME`: Storage account name
  - `AZURE_STORAGE_CONTAINER_NAME`: Blob container name (e.g., "photos")
  - `SPRING_JPA_DATABASE_PLATFORM`: org.hibernate.dialect.PostgreSQLDialect
  - `SPRING_DATASOURCE_DRIVER_CLASS_NAME`: org.postgresql.Driver
  - `APPLICATIONINSIGHTS_CONNECTION_STRING`: Application Insights connection string
  - `SPRING_JPA_HIBERNATE_DDL_AUTO`: update (for production, use validate)
- **dockerFilePath:** /home/runner/work/PhotoAlbum-Java/PhotoAlbum-Java/Dockerfile
- **dockerContext:** /home/runner/work/PhotoAlbum-Java/PhotoAlbum-Java

**Dependencies Resources:**

1. **Azure Database for PostgreSQL**
   - **Service Type:** Azure Database for PostgreSQL Flexible Server
   - **SKU:** Burstable_B1ms (1 vCore, 2 GiB RAM, 32 GiB storage)
   - **Performance:** Suitable for development/small production workloads, burst performance capability
   - **Connection Type:** Connection string with username/password stored in Key Vault, managed identity for future enhancement
   - **Environment Variables:**
     - `POSTGRES_CONNECTION_STRING`: Full connection string
     - `POSTGRES_SERVER`: Server hostname
     - `POSTGRES_DATABASE`: Database name (default: photoalbum)
     - `POSTGRES_USERNAME`: Admin username
     - `POSTGRES_PASSWORD`: Admin password (stored in Key Vault)

2. **Azure Storage Account**
   - **Service Type:** Azure Storage Account (Blob Storage)
   - **SKU:** Standard_LRS (Locally Redundant Storage)
   - **Performance:** Standard performance tier with hot access tier for frequent access
   - **Connection Type:** Managed Identity with Storage Blob Data Contributor role
   - **Environment Variables:**
     - `AZURE_STORAGE_ACCOUNT_NAME`: Storage account name
     - `AZURE_STORAGE_ACCOUNT_KEY`: Access key (stored in Key Vault)
     - `AZURE_STORAGE_CONNECTION_STRING`: Connection string (from Key Vault)
     - `AZURE_STORAGE_CONTAINER_NAME`: Container name for photos

3. **Azure Container Registry**
   - **Service Type:** Azure Container Registry
   - **SKU:** Basic (suitable for low throughput scenarios)
   - **Performance:** 10 GiB storage, adequate for single application
   - **Connection Type:** Managed Identity with AcrPull role
   - **Environment Variables:** None (handled through managed identity)

## **Recommended Supporting Services**

1. **Application Insights**
   - Monitor application performance, track requests, exceptions, and dependencies
   - Automatic instrumentation for Spring Boot applications
   - Connection string provided via environment variable

2. **User-Assigned Managed Identity**
   - Single identity for all service-to-service authentication
   - Eliminates need for storing credentials in application code
   - Assigned to Container App with appropriate role assignments

3. **Log Analytics Workspace**
   - Centralized logging for all Azure resources
   - Connected to Application Insights for unified monitoring
   - Container App logs automatically flow to this workspace

4. **Azure Key Vault**
   - Stores sensitive configuration:
     - PostgreSQL connection string and credentials
     - Storage account access keys
     - Any other application secrets
   - Accessed by Container App via managed identity

## **Recommended Security Configurations**

1. **User-Assigned Managed Identity Permissions:**
   - **Key Vault:** "Key Vault Secrets User" role for reading secrets
   - **Storage Account:** "Storage Blob Data Contributor" role for blob operations
   - **Container Registry:** "AcrPull" role (7f951dda-4ed3-4680-a7ca-43fe172d538d) for pulling images

2. **Identity Assignment:**
   - User-Assigned Managed Identity must be assigned to the Container App
   - All role assignments must be completed before application deployment

3. **Network Security:**
   - Container Apps Environment with internal ingress option available
   - PostgreSQL server with firewall rules allowing Azure services
   - Storage account with firewall configuration for Azure services

4. **Database Security:**
   - PostgreSQL with SSL enforcement enabled
   - Minimum TLS version 1.2
   - Admin credentials stored in Key Vault

## **Execution Steps**

> **Below are the steps for Copilot to follow; ask Copilot to update or execute this plan. Add check list for the steps.**

### 1. Containerization:

- [x] Analyze repository structure with appmod-analyze-repository
- [ ] Review existing Dockerfile at `/home/runner/work/PhotoAlbum-Java/PhotoAlbum-Java/Dockerfile`
- [ ] Verify Dockerfile compatibility with Azure Container Apps
- [ ] If needed, generate optimized Dockerfile using `appmod-plan-generate-dockerfile` tool
- [ ] Update application code for PostgreSQL compatibility (if not done):
  - Add PostgreSQL JDBC driver to `pom.xml`
  - Update `application.properties` for PostgreSQL configuration
  - Modify storage logic to use Azure Blob Storage SDK
- [ ] Test container build locally: `docker build -t photoalbum-java:test .`
- **Output:** Docker artifacts ready for Azure deployment

### 2. Create Azure Infrastructure Files for AZD:

- [ ] **Provisioning tool:** AZD
- [ ] **Expected files:** 
  - `azure.yaml` (AZD configuration)
  - `infra/main.bicep` (Infrastructure as Code)
  - `infra/main.parameters.json` (Bicep parameters)
  - `infra/resources.bicep` (Resource definitions)

**Steps:**

1. [ ] Get current Azure subscription ID
2. [ ] Call tool `appmod-get-available-region-sku` to get available regions and SKUs for:
   - `Microsoft.App/containerApps`
   - `Microsoft.DBforPostgreSQL/flexibleServers`
   - `Microsoft.Storage/storageAccounts`
   - `Microsoft.ContainerRegistry/registries`
   - `Microsoft.KeyVault/vaults`
   - `Microsoft.Insights/components`

3. [ ] Check if expected files exist:
   - **If files exist:** Verify they match plan requirements, update if needed
   - **If files don't exist:** Generate new files

4. [ ] Generate missing infrastructure files:
   - [ ] Call `appmod-get-iac-rules` with parameters:
     - deploymentTool: azd
     - iacType: bicep
     - resourceTypes: [containerapp, azuredatabaseforpostgresql, azurestorageaccount, azurecontainerregistry, azurekeyvault]
   - [ ] Generate `azure.yaml` with service definitions
   - [ ] Generate `infra/main.bicep` with all Azure resources
   - [ ] Generate `infra/main.parameters.json` with parameter values
   - [ ] Generate supporting Bicep modules as needed

5. [ ] Validate Bicep files:
   - [ ] Run `az bicep build -f infra/main.bicep` to check syntax
   - [ ] Fix any errors and retry
   - [ ] Use `get_errors` tool if available

### 3. Environment Setup for AZD:

1. [ ] **Install prerequisites:**
   - [ ] Check if Azure CLI is installed: `az --version`
   - [ ] If not, install: `curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash`
   - [ ] Check if AZD is installed: `azd version`
   - [ ] If not, install: `curl -fsSL https://aka.ms/install-azd.sh | bash`

2. [ ] **Login to Azure:**
   - [ ] Run `az login` to authenticate
   - [ ] Run `azd auth login` to authenticate AZD

3. [ ] **Create AZD environment:**
   - [ ] Generate environment name: `photoalbum-{random-suffix}` (e.g., `photoalbum-dev-001`)
   - [ ] Run: `azd env new photoalbum-dev-001 --no-prompt`
   - [ ] If environment exists, verify it matches requirements

4. [ ] **Set environment variables:**
   - [ ] Review `infra/main.bicep` and `infra/main.parameters.json` for required variables
   - [ ] Set Azure subscription: `azd env set AZURE_SUBSCRIPTION_ID <subscription-id>`
   - [ ] Set location/region: `azd env set AZURE_LOCATION <region>` (use result from step 2.2)
   - [ ] Set environment name: `azd env set AZURE_ENV_NAME photoalbum-dev-001`
   - [ ] Set resource group: `azd env set AZURE_RESOURCE_GROUP rg-photoalbum-dev-001`
   - [ ] Set any additional required variables from Bicep parameters

5. [ ] **Create resource group:**
   - [ ] Check if resource group scope is used in Bicep
   - [ ] If yes, create resource group: `az group create --name rg-photoalbum-dev-001 --location <region>`

### 4. Deployment:

1. [ ] **Dry run infrastructure:**
   - [ ] Run: `azd provision --preview --no-prompt`
   - [ ] Review the preview output
   - [ ] Confirm all resources are correctly configured

2. [ ] **Deploy to Azure:**
   - [ ] Run: `azd up --no-prompt`
   - [ ] Monitor deployment progress
   - [ ] If errors occur:
     - [ ] Review error messages
     - [ ] Fix infrastructure files or configuration
     - [ ] If region change needed: `azd down --force --no-prompt` first
     - [ ] Retry deployment

3. [ ] **Validate deployment:**
   - [ ] Check application logs: Use `appmod-get-azd-app-logs` tool
   - [ ] Verify services are running:
     - [ ] Container App is running and accessible
     - [ ] PostgreSQL database is provisioned and accessible
     - [ ] Storage account and blob container created
     - [ ] Application Insights receiving telemetry
   - [ ] Test application functionality:
     - [ ] Access application URL
     - [ ] Upload test photo
     - [ ] View gallery
     - [ ] Verify photos are stored in Azure Blob Storage
     - [ ] Check database connection

### 5. Summarize Deployment Result:

1. [ ] **Generate deployment summary:**
   - [ ] Use `appmod-summarize-result` tool with parameters:
     - workspaceFolder: /home/runner/work/PhotoAlbum-Java/PhotoAlbum-Java
     - projectName: PhotoAlbum-Java
     - deploymentStatus: success/failure
     - createdFileNames: [list of created files]
     - deploymentRounds: [number of attempts]
     - provisionedResourceTypes: [list of Azure resource types]
     - deploymentTool: azd
     - subscriptionId: [Azure subscription ID]

2. [ ] **Output file:** `.azure/summary.copilotmd`

3. [ ] **Update documentation:**
   - [ ] Add Azure deployment section to README.md
   - [ ] Document environment variables and configuration
   - [ ] Add troubleshooting guide for Azure deployment

## **Progress Tracking**

Progress will be tracked in `.azure/progress.copilotmd` after each step:

**Format:**
- ‚úÖ [x] Completed tasks
- üî≤ [ ] Pending tasks
- ‚ùå Failed tasks with error notes and resolution attempts

**Example:**
- [x] Repository analysis completed (1 module detected: Spring Boot Java 8)
- [x] Dockerfile exists at ./Dockerfile
- [ ] Azure infrastructure files generation in progress
  - Attempt 1: Generating bicep files...
- [ ] AZD environment setup pending
- [ ] Deployment not started

**Error Handling:**
- If a step fails, log the error with details
- Regenerate or fix the problematic component
- Retry the step
- Update progress tracking with resolution notes
- Continue only after successful completion

## **Migration Notes**

1. **Database Migration (Oracle to PostgreSQL):**
   - Add PostgreSQL driver dependency: `org.postgresql:postgresql`
   - Update Hibernate dialect: `org.hibernate.dialect.PostgreSQLDialect`
   - Change JDBC URL format: `jdbc:postgresql://`
   - Test schema compatibility (Oracle-specific types may need adjustment)
   - Consider data migration strategy for existing Oracle data

2. **Storage Migration (DB BLOBs to Azure Blob Storage):**
   - Add Azure Storage SDK: `com.azure:azure-storage-blob`
   - Implement Azure Blob Storage service adapter
   - Update PhotoService to use blob storage instead of database
   - Keep `file_path` column for blob reference
   - Photo metadata remains in database, binary data in blob storage

3. **Configuration Externalization:**
   - Use Azure Key Vault for sensitive configuration
   - Update `application.properties` to use environment variables
   - Consider Azure App Configuration for non-sensitive settings
   - Use Spring Boot's Key Vault integration

4. **Monitoring and Observability:**
   - Application Insights auto-instrumentation for Spring Boot
   - Custom metrics for photo upload/view operations
   - Set up alerts for failures and performance degradation
   - Log aggregation in Log Analytics

## **Post-Deployment Checklist**

- [ ] Application is accessible via public URL
- [ ] Photo upload functionality works
- [ ] Photos are stored in Azure Blob Storage
- [ ] Gallery view displays uploaded photos
- [ ] Photo detail view and navigation work
- [ ] Database queries are performing well
- [ ] Application Insights shows telemetry
- [ ] No errors in Container App logs
- [ ] Secrets are stored in Key Vault (not hardcoded)
- [ ] Managed Identity authentication is working
- [ ] Cost monitoring is configured
- [ ] Backup strategy is in place for database and storage
- [ ] CI/CD pipeline can be set up (future step)
